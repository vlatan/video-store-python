{% extends "layout.html" %}
{% block css %}
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/home.css') }}">
{% endblock css %}

{% block title %}
<title>Doxder</title>
{% endblock title %}

{% block content %}
<!-- div to contain the content -->
<div id="scroller" class="home-content">

	{% for post in posts %}

	<a class="home-video-link" href="{{ url_for('posts.post', post_id=post.id) }}">
		<img class="home-video-img" src="{{ post.thumbnails['medium']['url'] }}"
			width="{{ post.thumbnails['medium']['width'] }}" height="{{ post.thumbnails['medium']['height'] }}"
			alt="{{ post.title }}">
		<h2 class="home-video-title">{{ post.title }}</h2>
	</a>

	{% endfor %}

	<template id="post_template">
		<!-- template content -->
		<a class="home-video-link" href="#">
			<img class="home-video-img" src="#">
			<h2 class="home-video-title"></h2>
		</a>
	</template>

</div>

<!-- element to trigger the IntersectionObserver -->
<div class="sentinel" id="sentinel">
	<div class="spinner-border" role="status"></div>
</div>
{% endblock content %}

{% block scripts %}
<script>
	// Get references to the dom elements
	var scroller = document.querySelector("#scroller");
	var template = document.querySelector('#post_template');
	var sentinel = document.querySelector('#sentinel');
	// Use infinite scroll from the second page onwards
	var counter = 2;
	// There are still posts to be fetched
	var the_end = false;

	// Function to request new items and render to the dom
	async function loadItems(url = '', data = {}) {

		// Use fetch to request data by passing the page number via POST method
		await fetch(url, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(data)
		}).then((response) => {

			// Convert the response data to JSON
			response.json().then((data) => {

				// If empty JSON, exit the function
				if (!data.length) {
					// Replace the spinner with "No more posts"
					sentinel.innerHTML = "No more posts";
					// We got to the end, no more posts
					the_end = true;
					return;
				}

				// Iterate over the items in the response
				for (var i = 0; i < data.length; i++) {

					// Clone the HTML template
					let template_clone = template.content.cloneNode(true);

					// Query & update the template content
					template_clone.querySelector('.home-video-link').href = `/post/${data[i]['id']}/`;
					let thumb = template_clone.querySelector('.home-video-img');
					thumb.src = data[i]['thumbnails']['medium']['url'];
					thumb.alt = data[i]['title'];
					template_clone.querySelector('.home-video-title').innerHTML = data[i]['title'];

					// Append template to dom
					scroller.appendChild(template_clone);
				}

				// Increment the page counter
				counter += 1;
			})
		})
	}

	if ('IntersectionObserver' in window) {
		// Create a new IntersectionObserver instance
		let intersectionObserver = new IntersectionObserver(([entry]) => {
			// If there are still posts and the entry is intersecting
			if (the_end == false && entry.isIntersecting) {
				// Call the loadItems function
				loadItems('/', { page: counter });
				// Unobserve the entry
				// intersectionObserver.unobserve(entry);
			}
			// add root margin for better intersection detecetion
		}, { rootMargin: "200px 0px" });

		// Instruct the IntersectionObserver to watch the sentinel
		intersectionObserver.observe(sentinel);
	}
</script>
{% endblock scripts %}